% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/findSpatiallyVariableFeaturesBayes.R
\name{findSpatiallyVariableFeaturesBayes}
\alias{findSpatiallyVariableFeaturesBayes}
\title{Identify spatially variable genes in a Bayesian manner.}
\usage{
findSpatiallyVariableFeaturesBayes(
  sp.obj = NULL,
  naive.hvgs = NULL,
  likelihood = "gaussian",
  lscale.estimator = "kmeans",
  n.iter = 3000L,
  kernel = "exp_quad",
  kernel.smoothness = 1.5,
  kernel.period = 100L,
  n.basis.fns = 20L,
  algorithm = "meanfield",
  mle.init = TRUE,
  mle.iter = 1000L,
  gene.depth.adjust = FALSE,
  n.draws = 1000L,
  elbo.samples = NULL,
  opencl.params = NULL,
  n.cores = 2L,
  random.seed = 312,
  verbose = TRUE,
  save.model = FALSE
)
}
\arguments{
\item{sp.obj}{An object of class \code{Seurat} containing spatial data. Defaults to NULL.}

\item{naive.hvgs}{A vector containing genes that have been classified as naive HVGs from which SVGs will be detected. Defaults to NULL.}

\item{likelihood}{A string specifying the likelihood to be used when fitting the model. Must be one of "gaussian" or "nb" (for Negative-binomial). Defaults to "gaussian".}

\item{lscale.estimator}{A string specifying how the global length-scale should be estimated. Must be one of "kmeans" or "variogram". Defaults to "kmeans".}

\item{n.iter}{An integer specifying the maximum number of iterations. Defaults to 3000.}

\item{kernel}{A string specifying the covariance kernel to be used when fitting the GP. Must be one of "exp_quad", "matern", or "periodic". Defaults to "exp_quad".}

\item{kernel.smoothness}{A double specifying the smoothness parameter \eqn{\nu} used when computing the Matern kernel. Must be one of 0.5, 1.5, or 2.5. Using 0.5 corresponds to the exponential kernel. Defaults to 1.5.}

\item{kernel.period}{An integer specifying the period parameter \eqn{p} used when computing the periodic kernel. Defaults to 100.}

\item{n.basis.fns}{An integer specifying the number of basis functions to be used when approximating the GP as a Hilbert space. Defaults to 20.}

\item{algorithm}{A string specifying the variational inference (VI) approximation algorithm to be used. Must be one of "meanfield", "fullrank", or "pathfinder". Defaults to "meanfield".}

\item{mle.init}{A Boolean specifying whether the the VI algorithm should be initialized using the MLE for each parameter. In general, this isn't strictly necessary but can help if the VI algorithm struggles to converge when provided with the default initialization (zero). Cannot be used when the Pathfinder algorithm is specified. Defaults to TRUE.}

\item{mle.iter}{An integer specifying the maximum number of optimization iterations used when \code{mle.init = TRUE}. Defaults to 1000.}

\item{gene.depth.adjust}{A Boolean specifying whether the model should include a fixed effect term for total gene expression. Defaults to FALSE.}

\item{n.draws}{An integer specifying the number of draws to be generated from the variational posterior. Defaults to 1000.}

\item{elbo.samples}{An integer specifying the number of samples to be used to estimate the ELBO at every 100th iteration. Higher values will provide a more accurate estimate at the cost of computational complexity. Defaults to 150 when \code{algorithm} is one of "meanfield" or "fullrank", 50 when \code{algorithm} is "pathfinder".}

\item{opencl.params}{A two-element double vector specifying the platform and device IDs of the OpenCL GPU device. Most users should specify \code{c(0, 0)}. See \code{\link[brms]{opencl}} for more details. Defaults to NULL.}

\item{n.cores}{An integer specifying the number of threads used in compiling and fitting the model. Defaults to 2.}

\item{random.seed}{A double specifying the random seed to be used when fitting and sampling from the model. Defaults to 312.}

\item{verbose}{A Boolean specifying whether or not verbose model output should be printed to the console. Defaults to TRUE.}

\item{save.model}{A Boolean specifying whether or not the fitted model generated by \code{\link[cmdstanr]{cmdstan_model}} should be saved to the unstructured metadata of \code{sp.obj}. Defaults to FALSE.}
}
\value{
Depending on the input, either an object of class \code{Seurat} or \code{SpatialExperiment} with gene-level statistics added to the appropriate metadata slot.
}
\description{
This function implements SVG estimation using Bayesian variational inference to approximate the posterior distribution of each gene's expression while accounting for spatial trends.
}
\details{
\itemize{
\item Prior to running this function, it is necessary to identify a naive set of highly variable genes (HVGs). Use e.g., \code{\link[Seurat]{FindVariableFeatures}} or \code{\link[scran]{modelGeneVar}} depending on the class of \code{sp.obj}.
\item There are two options when choosing a likelihood for gene expression - the Gaussian (which uses normalized, scaled data), and the Negative-binomial, which uses raw counts. Both options provide comparable results, with the Negative-binomial being perhaps a bit more accurate at the expense of slightly longer runtimes. First-time users should start with the Gaussian, while more experienced users should utilize the Negative-binomial. As always, it is a good idea to run both options and compare results if you're unsure of which is best for your data.
\item This function utilizes an approximate multivariate hierarchical Gaussian process (GP) to model spatial variation in gene expression. The primary parameter of interest is the per-gene amplitude (marginal standard deviation) \eqn{\tau_g} of the GP, which can be interpreted as a scaling factor for how much spatial location contributes to mean expression.
\item The term "approximate" in reference to the GP means that the the full GP is instead represented as a Hilbert space using basis functions. The basis function computation requires a kernel, here either the exponentiated quadratic (the default) or one of the Matern-family kernels. In short, the exponentiated quadratic kernel assumes infinite smoothness, while the Matern-family kernels assume varying degrees of roughness depending on the value of the smoothness parameter \eqn{\nu}.
\item The length-scale \eqn{\ell} can be estimated in two ways. The default method is to utilize k-means clustering on the spatial coordinates and take the median of the distances between centroids. The second method is to use aggregated variograms fit using \code{\link[gstat]{variogram}}; this method tends to be slightly slower, and generally estimates smaller values of \eqn{\ell}. 
\item The argument \code{mle.init} is used to specify whether or not optimization should be performed via the L-BFGS algorithm to attempt to find the (regularized) maximum likelihood estimate (MLE), which is then used as initialization for the VI algorithm. This is often unnecessary, but can help with convergence issues in large / complex datasets.
\item While we have implemented GPU acceleration via OpenCL through the argument \code{opencl.params}, OpenCL acceleration is not supported on every machine. For example, Apple M-series chips do not support double-precision floating-points, which are necessary for Stan to compile with OpenCL support. For more information, see \href{https://discourse.mc-stan.org/t/gpus-on-mac-osx-apple-m1/23375/5}{this Stan forums thread}. In order to correctly specify the OpenCL platform and device IDs, use the \code{clinfo} command line utility.
\item The user can specify which VI algorithm to use to fit the model via the argument \code{algorithm}. For further details, see \href{https://www.jmlr.org/papers/volume18/16-107/16-107.pdf}{this paper} comparing the meanfield and fullrank algorithms, and \href{https://doi.org/10.48550/arXiv.2108.03782}{this preprint} that introduced the Pathfinder algorithm. For a primer on automatic differentiation variational inference (ADVI), see \href{https://doi.org/10.48550/arXiv.1506.03431}{this preprint}. Lastly, \href{https://discourse.mc-stan.org/t/issues-with-differences-between-mcmc-and-pathfinder-results-how-to-make-pathfinder-or-something-else-more-accurate/35992}{this Stan forums thread} lays out some practical differences between the algorithms.
\item If using the periodic kernel, the user should ideally provide their own value of \code{kernel.period} based on the resolution of the spatial dataset at hand. Typical values should be roughly equivalent to the typical inter-spot distance or perhaps a small multiple of it.
\item If \code{save.model} is set to TRUE, the final model fit will be saved to the appropriate unstructured metadata slot of \code{sp.obj}. This allows the user to inspect the final fit and perform posterior predictive checks, but the model object takes up a lot of space. As such, it is recommended to remove it from \code{sp.obj} by setting the appropriate slot to NULL before saving it to disk.
}
}
\examples{
data(seu_brain)
seu_brain <- Seurat::NormalizeData(seu_brain, verbose = FALSE) \%>\% 
             Seurat::FindVariableFeatures(nfeatures = 1000L, verbose = FALSE)
seu_brain <- findSpatiallyVariableFeaturesBayes(seu_brain,
                                                naive.hvgs = Seurat::VariableFeatures(seu_brain),
                                                kernel = "matern",
                                                kernel.smoothness = 1.5,
                                                algorithm = "meanfield",
                                                n.cores = 1L,
                                                save.model = TRUE)
}
\seealso{
\code{\link[Seurat]{FindSpatiallyVariableFeatures}}

\code{\link{findVariableFeaturesBayes}}
}
\author{
Jack R. Leary
}
