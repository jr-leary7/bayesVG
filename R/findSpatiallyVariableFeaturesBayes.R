#' Identify spatially variable genes in a Bayesian manner.
#'
#' @name findSpatiallyVariableFeaturesBayes
#' @author Jack R. Leary
#' @description This function implements HVG estimation using Bayesian variational inference to approximate the posterior distribution of the mean and overdispersion of each gene.
#' @param spatial.obj An object of class \code{Seurat} containing sptial data. Defaults to NULL.
#' @param n.spots.subsample An integer specifying the number of spots per-gene to subsample to when performing estimation. Defaults to 500.
#' @param iter.per.chain An integer specifying the number of iterations per chain. Defaults to 1000L.
#' @param warmup.per.chain An integer specifying the number of warmup (burn-in) iterations per chain. Defaults to 250.
#' @param covariance.kernel A string specifying the covariance kernel to be used when fitting the GP. See \code{\link[brms]{gp}} for a list of possible values. Defaults to "exp_quad".
#' @param n.basis.fns (Optional) An integer specifying the number of basis functions to be used when approximating the GP as a Hilbert space. Defaults to 20. 
#' @param n.chains (Optional) An integer specifying the number of chains used when performing variational inference. Defaults to 1.
#' @param thin.rate (Optional) An integer specifying the thinning rate of the VI algorithm. Defaults to 5.
#' @param n.cores.chain An integer specifying the number of cores to be used when fitting the Bayesian hierarchical Gaussian process model. Defaults to 1.
#' @param n.cores.per.chain An integer specifying the number of cores to be used within each chain when fitting the Bayesian hierarchical model. Defaults to 4.
#' @param model.priors A vector containing priors to be used in model fitting. If left NULL, intelligent priors will be set internally. See \code{\link[brms]{set_prior}} for details. Defaults to NULL.
#' @param algorithm (Optional) A string specifying the variational inference or sampling algorithm to be used. Must be one of "meanfield", "fullrank", "laplace", "pathfinder" (all approximate methods) or "sampling" for MCMC via NUTS. Note that MCMC will be slower than using a VI algorithm or the Laplace approximation. Defaults to "meanfield".
#' @param opencl.params (Optional) A two-element double vector specifying the platform and device IDs of the OpenCL GPU device. Most users should specify \code{c(0, 0)}. See \code{\link[brms]{opencl}} for more details. Defaults to NULL.
#' @param random.seed A double specifying the random seed to be used when fitting and sampling from the model. Defaults to 312.
#' @param verbose (Optional) A Boolean specifying whether or not verbose model output should be printed to the console. Defaults to FALSE.
#' @param save.model (Optional) A Boolean specifying whether or not the fitted model generated by \code{\link[brms]{brm}} should be saved to the unstructured metadata of \code{spatial.obj}. Defaults to FALSE.
#' @details
#' \itemize{
#' \item This function utilizes a multivariate Gaussian process (GP) to account for spatial variation while estimating per-gene means, variances, and dispersions.
#' }
#' @import magrittr
#' @import cmdstanr
#' @importFrom parallel detectCores
#' @importFrom Seurat GetAssayData DefaultAssay GetTissueCoordinates
#' @importFrom dplyr relocate mutate rename select inner_join filter distinct arrange desc rowwise ungroup left_join
#' @importFrom tidyr pivot_longer
#' @importFrom stats quantile kmeans dist 
#' @importFrom withr with_output_sink
#' @seealso \code{\link[Seurat]{FindSpatiallyVariableFeatures}}
#' @export 

findSpatiallyVariableFeaturesBayes <- function(spatial.obj = NULL,  
                                               iter.per.chain = 3000L, 
                                               n.basis.fns = 20L, 
                                               n.chains = 1L, 
                                               algorithm = "meanfield", 
                                               n.draws = 1000L, 
                                               opencl.params = NULL, 
                                               random.seed = 312, 
                                               verbose = FALSE, 
                                               save.model = FALSE) {
  # check & parse inputs
  if (is.null(spatial.obj)) { stop("Please provide all inputs to findSpatiallyVariableFeaturesBayes().") }
  if (n.chains > parallel::detectCores()) { stop("The total number of requested cores is greater than the number of available cores on your machine.") }
  algorithm <- tolower(algorithm)
  if (!algorithm %in% c("meanfield", "fullrank", "pathfinder")) { stop("Please provide a valid variational inference approximation algorithm.") }
  if (!is.null(opencl.params) && (!is.double(opencl.params) || !length(opencl.params) == 2)) { stop("Argument opencl.params must be a double vector of length 2 if non-NULL.") }
  if (is.null(opencl.params)) {
    opencl_IDs <- NULL
  } else {
    opencl_IDs <- opencl.params
  }
  # extract matrix of scaled, normalized gene expression
  expr_mat <- Seurat::GetAssayData(spatial.obj,
                                   assay = Seurat::DefaultAssay(spatial.obj),
                                   layer = "scale.data")
  # extract spatial coordinates
  spatial_df <- GetTissueCoordinates(seu_brain) %>%
                relocate(cell) %>%
                rename(spot = cell)
  spatial_mtx <- scale(as.matrix(select(spatial_df, -spot)))
  # extract gene expression matrix 
  expr_mtx <- GetAssayData(seu_brain,
                           assay = "SCT",
                           layer = "scale.data")
  # convert expression matrix to long data.frame for modeling
  expr_df <- as.data.frame(expr_mat) %>% 
             dplyr::mutate(gene = rownames(.), .before = 1) %>% 
             tidyr::pivot_longer(cols = !gene,
                                 names_to = "spot",
                                 values_to = "expression") %>%
             dplyr::relocate(spot, gene) %>% 
             dplyr::mutate(gene = factor(gene, levels = unique(gene)), 
                           spot = factor(gene, levels = unique(spot))) %>% 
             as.data.frame()
  # estimate global length-scale and matrix of basis functions for approximate GP 
  M <- nrow(spatial_mtx)
  k <- 20
  kmeans_centers <- stats::kmeans(spatial_mtx, centers = k, iter.max = 20L)$centers
  dists_centers <- as.matrix(stats::dist(kmeans_centers))
  lscale <- median(dists_centers[upper.tri(dists_centers)])
  phi <- matrix(0, nrow = M, ncol = k)
  for (i in seq(k)) {
    d2 <- rowSums((spatial_mtx - matrix(kmeans_centers[i, ], nrow = M, ncol = 2, byrow = TRUE))^2)
    phi[, i] <- exp(-d2 / (2 * lscale^2))
  }
  # pass data into model and fit 
  data_list <- list(M = M,
                    N = nrow(expr_df),
                    G = length(unique(expr_df$gene)),
                    k = k,
                    spot_id = expr_df$spot,
                    gene_id = expr_df$gene,
                    phi = phi,
                    y = expr_df$expression)
  mod <- cmdstanr::cmdstan_model("../gp-test.stan",
                                 stanc_options = list("O1"),
                                 threads = 2L)
  if (verbose) {
    if (algorithm %in% c("meanfield", "fullrank")) {
      fit_vi <- mod$variational(data_list,
                                seed = random.seed,
                                algorithm = algorithm,
                                iter =  iter.per.chain,
                                draws = n.draws)
    } else {
      fit_vi <- mod$pathfinder(data_list, 
                               seed = random.seed, 
                               draws = n.draws)
    }
  } else {
    withr::with_output_sink(tempfile(), {
      if (algorithm %in% c("meanfield", "fullrank")) {
        fit_vi <- mod$variational(data_list,
                                  seed = random.seed,
                                  algorithm = algorithm,
                                  iter =  iter.per.chain,
                                  draws = n.draws)
      } else {
        fit_vi <- mod$pathfinder(data_list, 
                                 seed = random.seed, 
                                 draws = n.draws)
      }
    })
  }
  # run diagnostics 
  if (verbose) { 
    fit_vi$cmdstan_diagnose()
  }
  # summarize posterior 
  draws_vi_summary <- fit_vi$summary()
  gene_mapping <- data.frame(gene = as.character(expr_df$gene),
                             gene_id = as.character(as.integer(expr_df$gene))) %>%
                  dplyr::distinct()
  amplitude_vi_summary <- dplyr::filter(draws_vi_summary, grepl("amplitude", variable)) %>%
                          dplyr::mutate(gene_id = sub("^.*\\[(.*)\\].*$", "\\1", variable), .before = 1) %>%
                          dplyr::inner_join(gene_mapping, by = "gene_id") %>%
                          dplyr::relocate(gene) %>%
                          dplyr::mutate(dispersion = sd^2 / mean) %>% 
                          dplyr::arrange(dplyr::desc(mean)) %>% 
                          dplyr::mutate(mean_rank = dplyr::row_number()) %>% 
                          dplyr::arrange(dplyr::desc(sd)) %>% 
                          dplyr::mutate(sd_rank = dplyr::row_number()) %>% 
                          dplyr::arrange(dplyr::desc(dispersion)) %>% 
                          dplyr::mutate(dispersion_rank = dplyr::row_number()) %>% 
                          dplyr::rowwise() %>% 
                          dplyr::mutate(overall_rank = mean(c(mean_rank, sd_rank, dispersion_rank))) %>% 
                          dplyr::ungroup() %>% 
                          magrittr::set_rownames(.$gene)
  if (verbose) {
    message("Posterior summarization complete!")
  }
  # add gene-level estimates to object metadata
  version_check <- try({
    slot(spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]], name = "meta.data")
  }, silent = TRUE)
  if (inherits(version_check, "try-error")) {
    orig_metadata <- spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@meta.features
  } else {
    orig_metadata <- spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@meta.data
  }
  if (ncol(orig_metadata) > 0) {
    new_metadata <- dplyr::mutate(orig_metadata,
                                  gene = rownames(spatial.obj),
                                  .before = 1) %>%
                    dplyr::left_join(gene_summary, by = "gene")
    if (inherits(version_check, "try-error")) {
      spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@meta.features <- new_metadata
    } else {
      spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@meta.data <- new_metadata
    }
  } else {
    gene_summary <- gene_summary[rownames(spatial.obj), ]
    if (inherits(version_check, "try-error")) {
      spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@meta.features <- gene_summary
    } else {
      spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@meta.data <- gene_summary
    }
  }
  # optionally save model fit to object's unstructured metadata
  if (save.model) {
    spatial.obj@assays[[Seurat::DefaultAssay(spatial.obj)]]@misc$brms_fit <- fit_vi
  }
  return(spatial.obj)
}
