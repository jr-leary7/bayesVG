#' Identify spatially variable genes in a Bayesian manner.
#'
#' @name findSpatiallyVariableFeaturesBayes
#' @author Jack R. Leary
#' @description This function implements SVG estimation using Bayesian variational inference to approximate the posterior distribution of each gene's expression while accounting for spatial trends.
#' @param sp.obj An object of class \code{Seurat} containing spatial data. Defaults to NULL.
#' @param iter.per.chain An integer specifying the number of iterations per chain. Defaults to 3000.
#' @param kernel A string specifying the covariance kernel to be used when fitting the GP. Must be one of "exp_quad" or "matern". Defaults to "exp_quad".
#' @param kernel.smoothness A double specifing the smoothness parameter \eqn{\nu} used when computing the Matern kernel. Must be one of 0.5, 1.5, or 2.5. Using 0.5 corresponds to the exponential kernel. Defaults to 1.5.
#' @param n.basis.fns (Optional) An integer specifying the number of basis functions to be used when approximating the GP as a Hilbert space. Defaults to 20.
#' @param algorithm (Optional) A string specifying the variational inference approximation algorithm to be used. Must be one of "meanfield", "fullrank", or "pathfinder". Defaults to "meanfield".
#' @param opencl.params (Optional) A two-element double vector specifying the platform and device IDs of the OpenCL GPU device. Most users should specify \code{c(0, 0)}. See \code{\link[brms]{opencl}} for more details. Defaults to NULL.
#' @param random.seed A double specifying the random seed to be used when fitting and sampling from the model. Defaults to 312.
#' @param verbose (Optional) A Boolean specifying whether or not verbose model output should be printed to the console. Defaults to TRUE.
#' @param save.model (Optional) A Boolean specifying whether or not the fitted model generated by \code{\link[cmdstanr]{cmdstan_model}} should be saved to the unstructured metadata of \code{spatial.obj}. Defaults to FALSE.
#' @details
#' \itemize{
#' \item This function utilizes an approximate multivariate hierarchical Gaussian process (GP) to model spatial variation in gene expression.
#' \item While we have implemented GPU acceleration via OpenCL through the argument \code{opencl.params}, OpenCL acceleration is not supported on every machine. For example, Apple M-series chips do not support double-precision floating-points, which are necessary for Stan to compile. For more information, see \href{https://discourse.mc-stan.org/t/gpus-on-mac-osx-apple-m1/23375/5}{this Stan forums thread}. In order to correctly specify the OpenCL platform and device IDs, use the \code{clinfo} command line utility.
#' \item The user can specify which variational inference (VI) to use to fit the model via the argument \code{algorithm}. For further details, see \href{https://www.jmlr.org/papers/volume18/16-107/16-107.pdf}{this paper} comparing the meanfield and fullrank algorithms, and \href{https://doi.org/10.48550/arXiv.2108.03782}{this preprint} that introduced the Pathfinder algorithm. For a primer on automatic differentiation variational inference (ADVI), see \href{https://doi.org/10.48550/arXiv.1506.03431}{this preprint}. Lastly, \href{https://discourse.mc-stan.org/t/issues-with-differences-between-mcmc-and-pathfinder-results-how-to-make-pathfinder-or-something-else-more-accurate/35992}{this Stan forums thread} lays out some pratical differences between the algorithms.
#' \item If \code{save.model} is set to TRUE, the final model fit will be saved to the appropriate unstructured metadata slot of \code{sp.obj}. This allows the user to inspect the final fit and perform posterior predictive checks, but the model object takes up a lot of space. As such, it is recommended to remove it from \code{sp.obj} by setting the appropriate slot to NULL before saving it to disk.
#' }
#' @import magrittr
#' @import cmdstanr
#' @importFrom parallel detectCores
#' @importFrom Seurat GetAssayData DefaultAssay GetTissueCoordinates VariableFeatures
#' @importFrom dplyr relocate mutate rename select inner_join filter distinct arrange desc rowwise ungroup left_join
#' @importFrom tidyr pivot_longer
#' @importFrom forcats fct_drop
#' @importFrom stats kmeans dist
#' @importFrom withr with_output_sink
#' @seealso \code{\link[Seurat]{FindSpatiallyVariableFeatures}}
#' @export

findSpatiallyVariableFeaturesBayes <- function(sp.obj = NULL,
                                               n.iter = 3000L,
                                               kernel = "exp_quad",
                                               kernel.smoothness = 1.5,
                                               n.basis.fns = 20L,
                                               algorithm = "meanfield",
                                               n.draws = 1000L,
                                               opencl.params = NULL,
                                               random.seed = 312,
                                               verbose = TRUE,
                                               save.model = FALSE) {
  # check & parse inputs
  if (is.null(sp.obj)) { stop("Please provide all inputs to findSpatiallyVariableFeaturesBayes().") }
  kernel <- tolower(kernel)
  if (!kernel %in% c("exp_quad", "matern")) { stop("Please provide a valid covariance kernel.") }
  if (kernel == "matern" && !kernel.smoothness %in% c(0.5, 1.5, 2.5)) { stop("When utilizing the Matern kernel you must provide a valid smoothness parameter value.") }
  algorithm <- tolower(algorithm)
  if (!algorithm %in% c("meanfield", "fullrank", "pathfinder")) { stop("Please provide a valid variational inference approximation algorithm.") }
  if (!is.null(opencl.params) && (!is.double(opencl.params) || !length(opencl.params) == 2)) { stop("Argument opencl.params must be a double vector of length 2 if non-NULL.") }
  if (is.null(opencl.params)) {
    opencl_IDs <- NULL
    cpp_options <- list(stan_opencl = FALSE)
  } else {
    opencl_IDs <- opencl.params
    cpp_options <- list(stan_opencl = TRUE)
  }
  # extract spatial coordinates & scale them
  spatial_df <- GetTissueCoordinates(seu_brain) %>%
                relocate(cell) %>%
                rename(spot = cell)
  spatial_mtx <- scale(as.matrix(select(spatial_df, -spot)))
  # extract matrix of normalized gene expression
  expr_mat <- Seurat::GetAssayData(sp.obj,
                                   assay = Seurat::DefaultAssay(sp.obj),
                                   layer = "data")
  # convert expression matrix to long data.frame for modeling & postprocess
  expr_df <- as.data.frame(expr_mat) %>%
             dplyr::mutate(gene = rownames(.), .before = 1) %>%
             tidyr::pivot_longer(cols = !gene,
                                 names_to = "spot",
                                 values_to = "expression") %>%
             dplyr::relocate(spot, gene) %>%
             dplyr::mutate(gene = factor(gene, levels = unique(gene)),
                           spot = factor(gene, levels = unique(spot)),
                           expression = as.numeric(scale(expression)))  %>% 
             dplyr::filter(gene %in% Seurat::VariableFeatures(seu_brain)) %>% 
             dplyr::mutate(gene = forcats::fct_drop(gene)) %>% 
             as.data.frame()
  # estimate global length-scale
  M <- nrow(spatial_mtx)
  k <- 20
  kmeans_centers <- stats::kmeans(spatial_mtx, centers = k, iter.max = 20L)$centers
  dists_centers <- as.matrix(stats::dist(kmeans_centers))
  lscale <- median(dists_centers[upper.tri(dists_centers)])
  # estimate matrix of basis functions for approximate GP using desired kernel
  phi <- matrix(0, nrow = M, ncol = k)
  for (i in seq(k)) {
    dist_vec <- rowSums((spatial_mtx - matrix(kmeans_centers[i, ], nrow = M, ncol = 2, byrow = TRUE))^2)
    if (kernel == "exp_quad") {
      phi[, i] <- expQuadKernel(dist_vec, length.scale = lscale)
    } else if (kernel == "matern") {
      phi[, i] <- maternKernel(dist_vec,
                               length.scale = lscale,
                               nu = kernel.smoothness)
    }
  }
  # scale basis functions
  phi <- scale(phi)
  attributes(phi) <- NULL
  # prepare data to be passed to cmdstan
  data_list <- list(M = M,
                    N = nrow(expr_df),
                    G = length(unique(expr_df$gene)),
                    k = k,
                    spot_id = expr_df$spot,
                    gene_id = expr_df$gene,
                    phi = phi,
                    y = expr_df$expression)
  # compile model
  mod <- cmdstanr::cmdstan_model("../src/stan/approxGP.stan",
                                 stanc_options = list("O1"),
                                 cpp_options = cpp_options,
                                 threads = 2L)
  # fit model with desired algorithm
  if (verbose) {
    if (algorithm %in% c("meanfield", "fullrank")) {
      fit_vi <- mod$variational(data_list,
                                seed = random.seed,
                                algorithm = algorithm,
                                iter =  n.iter,
                                draws = n.draws,
                                opencl_ids = opencl_IDs)
    } else {
      fit_vi <- mod$pathfinder(data_list,
                               seed = random.seed,
                               draws = n.draws,
                               opencl_ids = opencl_IDs)
    }
  } else {
    withr::with_output_sink(tempfile(), {
      if (algorithm %in% c("meanfield", "fullrank")) {
        fit_vi <- mod$variational(data_list,
                                  seed = random.seed,
                                  algorithm = algorithm,
                                  iter =  n.iter,
                                  draws = n.draws,
                                  opencl_ids = opencl_IDs)
      } else {
        fit_vi <- mod$pathfinder(data_list,
                                 seed = random.seed,
                                 draws = n.draws,
                                 opencl_ids = opencl_IDs)
      }
    })
  }
  # run diagnostics
  if (verbose) {
    fit_vi$cmdstan_diagnose()
  }
  # summarize posterior
  gene_mapping <- data.frame(gene = as.character(expr_df$gene),
                             gene_id = as.character(as.integer(expr_df$gene))) %>%
                  dplyr::distinct()
  amplitude_vi_summary <- fit_vi$summary(variables = "amplitude") %>%
                          dplyr::mutate(gene_id = sub("^.*\\[(.*)\\].*$", "\\1", variable), .before = 1) %>%
                          dplyr::inner_join(gene_mapping, by = "gene_id") %>%
                          dplyr::relocate(gene) %>%
                          dplyr::mutate(dispersion = sd^2 / mean) %>%
                          dplyr::arrange(dplyr::desc(mean)) %>%
                          dplyr::mutate(mean_rank = dplyr::row_number()) %>%
                          dplyr::arrange(dplyr::desc(sd)) %>%
                          dplyr::mutate(sd_rank = dplyr::row_number()) %>%
                          dplyr::arrange(dplyr::desc(dispersion)) %>%
                          dplyr::mutate(dispersion_rank = dplyr::row_number()) %>%
                          dplyr::rowwise() %>%
                          dplyr::mutate(overall_rank = mean(c(mean_rank, sd_rank, dispersion_rank))) %>%
                          dplyr::ungroup() %>%
                          magrittr::set_rownames(.$gene)
  if (verbose) {
    message("Posterior summarization complete!")
  }
  # add gene-level estimates to object metadata
  version_check <- try({
    slot(sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]], name = "meta.data")
  }, silent = TRUE)
  if (inherits(version_check, "try-error")) {
    orig_metadata <- sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features
  } else {
    orig_metadata <- sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data
  }
  if (ncol(orig_metadata) > 0) {
    new_metadata <- dplyr::mutate(orig_metadata,
                                  gene = rownames(sp.obj),
                                  .before = 1) %>%
                    dplyr::left_join(amplitude_vi_summary, by = "gene")
    if (inherits(version_check, "try-error")) {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features <- new_metadata
    } else {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data <- new_metadata
    }
  } else {
    amplitude_vi_summary <- amplitude_vi_summary[rownames(sp.obj), ]
    if (inherits(version_check, "try-error")) {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features <- amplitude_vi_summary
    } else {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data <- amplitude_vi_summary
    }
  }
  # optionally save model fit to object's unstructured metadata
  if (save.model) {
    sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@misc$brms_fit <- fit_vi
  }
  return(sp.obj)
}
