#' Identify spatially variable genes in a Bayesian manner.
#'
#' @name findSpatiallyVariableFeaturesBayes
#' @author Jack R. Leary
#' @description This function implements SVG estimation using Bayesian variational inference to approximate the posterior distribution of each gene's expression while accounting for spatial trends.
#' @param sp.obj An object of class \code{Seurat} containing spatial data. Defaults to NULL.
#' @param iter.per.chain An integer specifying the number of iterations per chain. Defaults to 3000.
#' @param kernel A string specifying the covariance kernel to be used when fitting the GP. Must be one of "exp_quad" or "matern". Defaults to "exp_quad".
#' @param kernel.smoothness A double specifing the smoothness parameter \eqn{\nu} used when computing the Matern kernel. Must be one of 0.5, 1.5, or 2.5. Using 0.5 corresponds to the exponential kernel. Defaults to 1.5.
#' @param n.basis.fns An integer specifying the number of basis functions to be used when approximating the GP as a Hilbert space. Defaults to 20.
#' @param algorithm A string specifying the variational inference (VI) approximation algorithm to be used. Must be one of "meanfield", "fullrank", or "pathfinder". Defaults to "meanfield".
#' @param mle.init A Boolean specifying whether the the VI algorithm should be initialized using the MLE for each parameter. In general, this increases both computational speed and the accuracy of the variational approximation. Defaults to TRUE.  
#' @param opencl.params A two-element double vector specifying the platform and device IDs of the OpenCL GPU device. Most users should specify \code{c(0, 0)}. See \code{\link[brms]{opencl}} for more details. Defaults to NULL.
#' @param n.cores An integer specifying the number of threads used in compiling and fitting the model. Defaults to 2. 
#' @param random.seed A double specifying the random seed to be used when fitting and sampling from the model. Defaults to 312.
#' @param verbose A Boolean specifying whether or not verbose model output should be printed to the console. Defaults to TRUE.
#' @param save.model A Boolean specifying whether or not the fitted model generated by \code{\link[cmdstanr]{cmdstan_model}} should be saved to the unstructured metadata of \code{spatial.obj}. Defaults to FALSE.
#' @details
#' \itemize{
#' \item Prior to running this function, it is necessary to identify a naive set of highly variable genes (HVGs). Use e.g., \code{\link[Seurat]{FindVariableFeatures}}. 
#' \item This function utilizes an approximate multivariate hierarchical Gaussian process (GP) to model spatial variation in gene expression. The primary parameter of interest is the per-gene amplitude (marginal standard deviation) \eqn{\tau_g} of the GP, which can be interpreted as a scaling factor for how much spatial location contributes to mean expression.
#' \item 
#' \item While we have implemented GPU acceleration via OpenCL through the argument \code{opencl.params}, OpenCL acceleration is not supported on every machine. For example, Apple M-series chips do not support double-precision floating-points, which are necessary for Stan to compile with OpenCL support. For more information, see \href{https://discourse.mc-stan.org/t/gpus-on-mac-osx-apple-m1/23375/5}{this Stan forums thread}. In order to correctly specify the OpenCL platform and device IDs, use the \code{clinfo} command line utility.
#' \item The user can specify which VI algorithm to use to fit the model via the argument \code{algorithm}. For further details, see \href{https://www.jmlr.org/papers/volume18/16-107/16-107.pdf}{this paper} comparing the meanfield and fullrank algorithms, and \href{https://doi.org/10.48550/arXiv.2108.03782}{this preprint} that introduced the Pathfinder algorithm. For a primer on automatic differentiation variational inference (ADVI), see \href{https://doi.org/10.48550/arXiv.1506.03431}{this preprint}. Lastly, \href{https://discourse.mc-stan.org/t/issues-with-differences-between-mcmc-and-pathfinder-results-how-to-make-pathfinder-or-something-else-more-accurate/35992}{this Stan forums thread} lays out some practical differences between the algorithms.
#' \item If \code{save.model} is set to TRUE, the final model fit will be saved to the appropriate unstructured metadata slot of \code{sp.obj}. This allows the user to inspect the final fit and perform posterior predictive checks, but the model object takes up a lot of space. As such, it is recommended to remove it from \code{sp.obj} by setting the appropriate slot to NULL before saving it to disk.
#' }
#' @import magrittr
#' @import cmdstanr
#' @importFrom parallel detectCores
#' @importFrom Seurat GetAssayData DefaultAssay GetTissueCoordinates VariableFeatures
#' @importFrom dplyr relocate mutate rename rename_with select inner_join desc filter distinct arrange left_join bind_rows
#' @importFrom tidyr pivot_longer
#' @importFrom stats kmeans dist
#' @importFrom withr with_output_sink
#' @seealso \code{\link[Seurat]{FindSpatiallyVariableFeatures}}
#' @seealso \code{findVariableFeaturesBayes}
#' @export

findSpatiallyVariableFeaturesBayes <- function(sp.obj = NULL,
                                               n.iter = 3000L,
                                               kernel = "exp_quad",
                                               kernel.smoothness = 1.5,
                                               n.basis.fns = 20L,
                                               algorithm = "meanfield",
                                               n.draws = 1000L,
                                               opencl.params = NULL,
                                               n.cores = 2L, 
                                               random.seed = 312,
                                               verbose = TRUE,
                                               save.model = FALSE) {
  # check & parse inputs
  if (is.null(sp.obj)) { stop("Please provide all inputs to findSpatiallyVariableFeaturesBayes().") }
  if (is.null(Seurat::VariableFeatures(sp.obj))) { stop("Please identify a set of naive HVGs prior to running findSpatiallyVariableFeaturesBayes().") }
  kernel <- tolower(kernel)
  if (!kernel %in% c("exp_quad", "matern")) { stop("Please provide a valid covariance kernel.") }
  if (kernel == "matern" && !kernel.smoothness %in% c(0.5, 1.5, 2.5)) { stop("When utilizing the Matern kernel you must provide a valid smoothness parameter value.") }
  algorithm <- tolower(algorithm)
  if (!algorithm %in% c("meanfield", "fullrank", "pathfinder")) { stop("Please provide a valid variational inference approximation algorithm.") }
  if (!is.null(opencl.params) && (!is.double(opencl.params) || !length(opencl.params) == 2)) { stop("Argument opencl.params must be a double vector of length 2 if non-NULL.") }
  if (is.null(opencl.params)) {
    opencl_IDs <- NULL
    cpp_options <- list(stan_opencl = FALSE, stan_threads = TRUE)
  } else {
    opencl_IDs <- opencl.params
    cpp_options <- list(stan_opencl = TRUE, stan_threads = TRUE)
  }
  if (n.cores > parallel::detectCores()) { stop("The number of requested cores is greater than the number of available cores.") }
  # extract spatial coordinates & scale them
  spatial_df <- Seurat::GetTissueCoordinates(seu_brain) %>%
                dplyr::relocate(cell) %>%
                dplyr::rename(spot = cell)
  spatial_mtx <- scale(as.matrix(select(spatial_df, -spot)))
  # extract matrix of normalized gene expression
  expr_mat <- Seurat::GetAssayData(sp.obj,
                                   assay = Seurat::DefaultAssay(sp.obj),
                                   layer = "data")
  # convert expression matrix to long data.frame for modeling & postprocess
  expr_df <- as.data.frame(expr_mtx[Seurat::VariableFeatures(seu_brain), ]) %>%
             dplyr::mutate(gene = rownames(.), .before = 1) %>%
             tidyr::pivot_longer(cols = !gene,
                                 names_to = "spot",
                                 values_to = "expression") %>%
             dplyr::relocate(spot, gene) %>%
             dplyr::mutate(gene = factor(gene, levels = unique(gene)),
                           spot = factor(gene, levels = unique(spot)),
                           expression = as.numeric(scale(expression)))  %>%
             as.data.frame()
  # estimate global length-scale
  M <- nrow(spatial_mtx)
  kmeans_centers <- stats::kmeans(spatial_mtx, centers = n.basis.fns, iter.max = 20L)$centers
  dists_centers <- as.matrix(stats::dist(kmeans_centers))
  lscale <- median(dists_centers[upper.tri(dists_centers)])
  # estimate matrix of basis functions for approximate GP using desired kernel
  phi <- matrix(0, nrow = M, ncol = n.basis.fns)
  for (i in seq(n.basis.fns)) {
    dist_vec <- rowSums((spatial_mtx - matrix(kmeans_centers[i, ], nrow = M, ncol = 2, byrow = TRUE))^2)
    if (kernel == "exp_quad") {
      phi[, i] <- expQuadKernel(dist_vec, length.scale = lscale)
    } else if (kernel == "matern") {
      phi[, i] <- maternKernel(dist_vec,
                               length.scale = lscale,
                               nu = kernel.smoothness)
    }
  }
  # scale basis functions
  phi <- scale(phi)
  attributes(phi)[2:3] <- NULL
  # prepare data to be passed to cmdstan
  data_list <- list(M = M,
                    N = nrow(expr_df),
                    G = length(unique(expr_df$gene)),
                    k = k,
                    spot_id = as.integer(expr_df$spot),
                    gene_id = as.integer(expr_df$gene),
                    phi = phi,
                    y = expr_df$expression)
  # compile model
  mod <- cmdstanr::cmdstan_model("../src/stan/approxGP.stan",
                                 stanc_options = list("O1"),
                                 cpp_options = cpp_options,
                                 force_recompile = TRUE,
                                 threads = n.cores)
  # fit MLE model to serve as initilization 
  if (mle.init) {
    fit_mle <- mod$optimize(data_list,
                            seed = random.seed, 
                            init = 0, 
                            jacobian = FALSE, 
                            threads = n.cores, 
                            iter = 1000L)
  } else {
    fit.mle <- NULL
  }
  # fit model with desired algorithm
  if (verbose) {
    if (algorithm %in% c("meanfield", "fullrank")) {
      fit_vi <- mod$variational(data_list,
                                seed = random.seed,
                                init = fit_mle, 
                                threads = n.cores, 
                                algorithm = algorithm,
                                iter =  n.iter,
                                draws = n.draws,
                                opencl_ids = opencl_IDs)
    } else {
      fit_vi <- mod$pathfinder(data_list,
                               seed = random.seed,
                               init = fit_mle, 
                               num_threads = n.cores, 
                               draws = n.draws,
                               opencl_ids = opencl_IDs)
    }
  } else {
    withr::with_output_sink(tempfile(), {
      if (algorithm %in% c("meanfield", "fullrank")) {
        fit_vi <- mod$variational(data_list,
                                  seed = random.seed,
                                  init = fit_mle, 
                                  threads = n.cores, 
                                  algorithm = algorithm,
                                  iter =  n.iter,
                                  draws = n.draws,
                                  opencl_ids = opencl_IDs)
      } else {
        fit_vi <- mod$pathfinder(data_list,
                                 seed = random.seed,
                                 init = fit_mle, 
                                 num_threads = n.cores, 
                                 draws = n.draws,
                                 opencl_ids = opencl_IDs)
      }
    })
  }
  # optionally run diagnostics
  if (verbose) {
    fit_vi$cmdstan_diagnose()
  }
  # summarize posterior
  gene_mapping <- data.frame(gene = as.character(expr_df$gene),
                             gene_id = as.character(as.integer(expr_df$gene))) %>%
                  dplyr::distinct()
  amplitude_summary <- fit_vi$summary(variables = "amplitude") %>%
                       dplyr::rename_with(~paste0("amplitude_", .), .cols = -1) %>%
                       dplyr::rename(amplitud_ci_ll = amplitude_q5,
                                     amplitude_ci_ul = amplitude_q95) %>%
                       dplyr::mutate(gene_id = sub("^.*\\[(.*)\\].*$", "\\1", variable), .before = 1) %>%
                       dplyr::inner_join(gene_mapping, by = "gene_id") %>%
                       dplyr::relocate(gene) %>%
                       dplyr::select(-c(variable, gene_id)) %>%
                       dplyr::mutate(amplitude_dispersion = amplitude_sd^2 / amplitude_mean) %>%
                       dplyr::arrange(dplyr::desc(amplitude_mean)) %>%
                       dplyr::mutate(amplitude_mean_rank = row_number()) %>%
                       as.data.frame() %>% 
                       magrittr::set_rownames(.$gene)
  if (verbose) {
    message("Posterior summarization complete!")
  }
  # add gene-level estimates to object metadata
  version_check <- try({
    slot(sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]], name = "meta.data")
  }, silent = TRUE)
  if (inherits(version_check, "try-error")) {
    orig_metadata <- sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features
  } else {
    orig_metadata <- sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data
  }
  if (ncol(orig_metadata) > 0) {
    new_metadata <- dplyr::mutate(orig_metadata,
                                  gene = rownames(sp.obj),
                                  .before = 1) %>%
                    dplyr::left_join(amplitude_summary, by = "gene")
    if (inherits(version_check, "try-error")) {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features <- new_metadata
    } else {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data <- new_metadata
    }
  } else {
    non_tested_genes <- rownames(sp.obj)[!rownames(sp.obj) %in% unique(expr_df$gene)]
    null_df <- data.frame(gene = non_tested_genes, 
                          amplitude_mean = NA_real_, 
                          amplitude_median = NA_real_, 
                          amplitude_sd = NA_real_, 
                          amplitude_mad = NA_real_, 
                          amplitud_ci_ll = NA_real_, 
                          amplitud_ci_ul = NA_real_, 
                          amplitude_dispersion = NA_real_, 
                          amplitude_mean_rank = NA_integer_) %>% 
               magrittr::set_rownames(.$gene)
    amplitude_summary <- dplyr::bind_rows(amplitude_summary, null_df)
    amplitude_summary <- amplitude_summary[rownames(sp.obj), ]
    if (inherits(version_check, "try-error")) {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features <- amplitude_summary
    } else {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data <- amplitude_summary
    }
  }
  # optionally save model fit to object's unstructured metadata
  if (save.model) {
    sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@misc$model_fit <- fit_vi
  }
  return(sp.obj)
}
