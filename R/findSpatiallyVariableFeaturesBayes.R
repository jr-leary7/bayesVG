#' Identify spatially variable genes in a Bayesian manner.
#'
#' @name findSpatiallyVariableFeaturesBayes
#' @author Jack R. Leary
#' @description This function implements SVG estimation using Bayesian variational inference to approximate the posterior distribution of each gene's expression while accounting for spatial trends.
#' @param sp.obj An object of class \code{Seurat} containing spatial data. Defaults to NULL.
#' @param naive.hvgs A vector containing genes that have been classified as naive HVGs from which SVGs will be detected. Defaults to NULL.
#' @param n.iter An integer specifying the maximum number of iterations. Defaults to 3000.
#' @param kernel A string specifying the covariance kernel to be used when fitting the GP. Must be one of "exp_quad", "matern", or "periodic". Defaults to "exp_quad".
#' @param kernel.smoothness A double specifying the smoothness parameter \eqn{\nu} used when computing the Matérn kernel. Must be one of 0.5, 1.5, or 2.5. Using 0.5 corresponds to the exponential kernel. Defaults to 1.5.
#' @param kernel.period An integer specifying the period parameter \eqn{p} used when computing the periodic kernel. Defaults to 100. 
#' @param n.basis.fns An integer specifying the number of basis functions to be used when approximating the GP as a Hilbert space. Defaults to 20.
#' @param algorithm A string specifying the variational inference (VI) approximation algorithm to be used. Must be one of "meanfield", "fullrank", or "pathfinder". Defaults to "meanfield".
#' @param mle.init A Boolean specifying whether the the VI algorithm should be initialized using the MLE for each parameter. In general, this increases both computational speed and the accuracy of the variational approximation. Cannot be used when the Pathfinder algorithm is specified. Defaults to TRUE.
#' @param gene.depth.adjust A Boolean specifying whether the model should include a fixed effect term for total gene expression. Defaults to TRUE.  
#' @param n.draws An integer specifying the number of draws to be generated from the variational posterior. Defaults to 1000.
#' @param elbo.samples An integer specifying the number of samples to be used to estimate the ELBO at every 100th iteration. Higher values will provide a more accurate estimate at the cost of computational complexity. Defaults to 150 when \code{algorithm} is one of "meanfield" or "fullrank", 50 when \code{algorithm} is "pathfinder".  
#' @param opencl.params A two-element double vector specifying the platform and device IDs of the OpenCL GPU device. Most users should specify \code{c(0, 0)}. See \code{\link[brms]{opencl}} for more details. Defaults to NULL.
#' @param n.cores An integer specifying the number of threads used in compiling and fitting the model. Defaults to 2.
#' @param random.seed A double specifying the random seed to be used when fitting and sampling from the model. Defaults to 312.
#' @param verbose A Boolean specifying whether or not verbose model output should be printed to the console. Defaults to TRUE.
#' @param save.model A Boolean specifying whether or not the fitted model generated by \code{\link[cmdstanr]{cmdstan_model}} should be saved to the unstructured metadata of \code{sp.obj}. Defaults to FALSE.
#' @details
#' \itemize{
#' \item Prior to running this function, it is necessary to identify a naive set of highly variable genes (HVGs). Use e.g., \code{\link[Seurat]{FindVariableFeatures}} or \code{\link[scran]{modelGeneVar}} depending on the class of \code{sp.obj}.
#' \item This function utilizes an approximate multivariate hierarchical Gaussian process (GP) to model spatial variation in gene expression. The primary parameter of interest is the per-gene amplitude (marginal standard deviation) \eqn{\tau_g} of the GP, which can be interpreted as a scaling factor for how much spatial location contributes to mean expression.
#' \item The term "approximate" in reference to the GP means that the the full GP is instead represented as a Hilbert space using basis functions. The basis function computation requires a kernel, here either the exponentiated quadratic (the default) or one of the Matérn-family kernels. In short, the exponentiated quadratic kernel assumes infinite smoothness, while the Matérn-family kernels assume varying degrees of roughness depending on the value of the smoothness parameter \eqn{\nu}.
#' \item While we have implemented GPU acceleration via OpenCL through the argument \code{opencl.params}, OpenCL acceleration is not supported on every machine. For example, Apple M-series chips do not support double-precision floating-points, which are necessary for Stan to compile with OpenCL support. For more information, see \href{https://discourse.mc-stan.org/t/gpus-on-mac-osx-apple-m1/23375/5}{this Stan forums thread}. In order to correctly specify the OpenCL platform and device IDs, use the \code{clinfo} command line utility.
#' \item The user can specify which VI algorithm to use to fit the model via the argument \code{algorithm}. For further details, see \href{https://www.jmlr.org/papers/volume18/16-107/16-107.pdf}{this paper} comparing the meanfield and fullrank algorithms, and \href{https://doi.org/10.48550/arXiv.2108.03782}{this preprint} that introduced the Pathfinder algorithm. For a primer on automatic differentiation variational inference (ADVI), see \href{https://doi.org/10.48550/arXiv.1506.03431}{this preprint}. Lastly, \href{https://discourse.mc-stan.org/t/issues-with-differences-between-mcmc-and-pathfinder-results-how-to-make-pathfinder-or-something-else-more-accurate/35992}{this Stan forums thread} lays out some practical differences between the algorithms.
#' \item If using the periodic kernel, the user should ideally provide their own value of \code{kernel.period} based on the resolution of the spatial dataset at hand. Typical values should be roughly equivalent to the typical inter-spot distance or perhaps a small multiple of it. 
#' \item If \code{save.model} is set to TRUE, the final model fit will be saved to the appropriate unstructured metadata slot of \code{sp.obj}. This allows the user to inspect the final fit and perform posterior predictive checks, but the model object takes up a lot of space. As such, it is recommended to remove it from \code{sp.obj} by setting the appropriate slot to NULL before saving it to disk.
#' }
#' @import magrittr
#' @import cmdstanr
#' @importFrom parallelly availableCores
#' @importFrom Seurat GetAssayData DefaultAssay GetTissueCoordinates
#' @importFrom SpatialExperiment spatialCoords
#' @importFrom SingleCellExperiment logcounts
#' @importFrom BiocGenerics counts
#' @importFrom Matrix rowSums 
#' @importFrom SummarizedExperiment rowData
#' @importFrom dplyr relocate mutate rename rename_with with_groups select inner_join desc filter distinct arrange left_join bind_rows
#' @importFrom tidyr pivot_longer
#' @importFrom stats kmeans dist median
#' @importFrom withr with_output_sink
#' @importFrom S4Vectors DataFrame
#' @importFrom cli cli_alert_success
#' @seealso \code{\link[Seurat]{FindSpatiallyVariableFeatures}}
#' @seealso \code{\link{findVariableFeaturesBayes}}
#' @export
#' @examples
#' data(seu_brain)
#' seu_brain <- Seurat::SCTransform(seu_brain,
#'                                  assay = "Spatial",
#'                                  variable.features.n = 3000L,
#'                                  vst.flavor = "v2",
#'                                  return.only.var.genes = FALSE,
#'                                  seed.use = 312,
#'                                  verbose = FALSE)
#' seu_brain <- findSpatiallyVariableFeaturesBayes(seu_brain, 
#'                                                 naive.hvgs = Seurat::VariableFeatures(seu_brain), 
#'                                                 kernel = "matern", 
#'                                                 kernel.smoothness = 1.5, 
#'                                                 algorithm = "meanfield", 
#'                                                 n.cores = 1L, 
#'                                                 save.model = TRUE)

findSpatiallyVariableFeaturesBayes <- function(sp.obj = NULL,
                                               naive.hvgs = NULL,
                                               n.iter = 3000L,
                                               kernel = "exp_quad",
                                               kernel.smoothness = 1.5,
                                               kernel.period = 100L, 
                                               n.basis.fns = 20L,
                                               algorithm = "meanfield",
                                               mle.init = TRUE,
                                               gene.depth.adjust = TRUE, 
                                               n.draws = 1000L,
                                               elbo.samples = NULL, 
                                               opencl.params = NULL,
                                               n.cores = 2L,
                                               random.seed = 312,
                                               verbose = TRUE,
                                               save.model = FALSE) {
  # check & parse inputs
  if (is.null(sp.obj)) { stop("Please provide a spatial data object to findSpatiallyVariableFeaturesBayes().") }
  if (!(inherits(sp.obj, "Seurat") || inherits(sp.obj, "SpatialExperiment"))) { stop("Please provide an object of class Seurat or SpatialExperiment.") }
  if (is.null(naive.hvgs)) { stop("Please identify a set of naive HVGs prior to running findSpatiallyVariableFeaturesBayes().") }
  kernel <- tolower(kernel)
  if (!kernel %in% c("exp_quad", "matern", "periodic")) { stop("Please provide a valid covariance kernel.") }
  if (kernel == "matern" && !kernel.smoothness %in% c(0.5, 1.5, 2.5)) { stop("When utilizing the Matern kernel you must provide a valid smoothness parameter value.") }
  algorithm <- tolower(algorithm)
  if (!algorithm %in% c("meanfield", "fullrank", "pathfinder")) { stop("Please provide a valid variational inference approximation algorithm.") }
  if (mle.init && algorithm == "pathfinder") { warning("Initialization at the MLE is not supported when using the Pathfinder algorithm.") }
  if (is.null(elbo.samples)) {
    if (algorithm == "pathfinder") {
      elbo.samples <- 50L
    } else {
      elbo.samples <- 150L
    }
  }
  if (!is.null(opencl.params) && (!is.double(opencl.params) || !length(opencl.params) == 2)) { stop("Argument opencl.params must be a double vector of length 2 if non-NULL.") }
  if (is.null(opencl.params)) {
    opencl_IDs <- NULL
    if (algorithm == "pathfinder") {
      cpp_options <- list(stan_threads = TRUE)
    } else {
      cpp_options <- list(stan_threads = FALSE)
    }
  } else {
    opencl_IDs <- opencl.params
    if (algorithm == "pathfinder") {
      cpp_options <- list(stan_opencl = TRUE, stan_threads = TRUE)
    } else {
      cpp_options <- list(stan_opencl = TRUE, stan_threads = FALSE)
    }
  }
  if (n.cores > unname(parallelly::availableCores())) { stop("The number of requested cores is greater than the number of available cores.") }
  # start time tracking 
  time_start <- Sys.time()
  # extract spatial coordinates & scale them
  if (inherits(sp.obj, "Seurat")) {
    spatial_df <- Seurat::GetTissueCoordinates(sp.obj) %>%
                  dplyr::select(1:2)
  } else {
   spatial_df <- SpatialExperiment::spatialCoords(sp.obj) %>%
                 as.data.frame()
  }
  spatial_mtx <- scale(as.matrix(spatial_df))
  # extract matrix of normalized gene expression
  if (inherits(sp.obj, "Seurat")) {
    expr_mtx <- Seurat::GetAssayData(sp.obj,
                                     assay = Seurat::DefaultAssay(sp.obj),
                                     layer = "data")
  } else {
    expr_mtx <- SingleCellExperiment::logcounts(sp.obj)
  }

  # convert expression matrix to long data.frame for modeling & postprocess
  expr_df <- as.data.frame(expr_mtx[naive.hvgs, ]) %>%
             dplyr::mutate(gene = rownames(.), .before = 1) %>%
             tidyr::pivot_longer(cols = !gene,
                                 names_to = "spot",
                                 values_to = "gene_expression") %>%
             dplyr::relocate(spot, gene) %>%
             dplyr::mutate(gene = factor(gene, levels = unique(gene)),
                           spot = factor(spot, levels = unique(spot)))  %>%
             dplyr::with_groups(gene, 
                                dplyr::mutate, 
                                gene_expression = as.numeric(scale(gene_expression)))
             as.data.frame()
  # estimate global length-scale
  M <- nrow(spatial_mtx)
  kmeans_centers <- stats::kmeans(spatial_mtx, centers = n.basis.fns, iter.max = 100L)$centers
  dists_centers <- as.matrix(stats::dist(kmeans_centers))
  lscale <- stats::median(dists_centers[upper.tri(dists_centers)])
  # estimate matrix of basis functions used to approximate GP with desired kernel
  phi <- matrix(0, nrow = M, ncol = n.basis.fns)
  for (i in seq(n.basis.fns)) {
    dist_vec <- rowSums((spatial_mtx - matrix(kmeans_centers[i, ], nrow = M, ncol = 2, byrow = TRUE))^2)
    if (kernel == "exp_quad") {
      phi[, i] <- expQuadKernel(dist_vec, length.scale = lscale)
    } else if (kernel == "matern") {
      phi[, i] <- maternKernel(dist_vec,
                               length.scale = lscale,
                               nu = kernel.smoothness)
    } else if (kernel == "periodic") {
      phi[, i] <- periodicKernel(dist_vec,
                                 length.scale = lscale,
                                 period = kernel.period)
    }
  }
  # scale basis functions
  phi <- scale(phi)
  attributes(phi)[2:3] <- NULL
  # prepare data to be passed to cmdstan
  if (gene.depth.adjust) {
    if (inherits(sp.obj, "Seurat")) {
      expr_tmp <- Seurat::GetAssayData(sp.obj,
                                       assay = Seurat::DefaultAssay(sp.obj),
                                       layer = "counts")
    } else {
      expr_tmp <- BiocGenerics::counts(sp.obj)
    }
    expr_tmp <- expr_tmp[naive.hvgs, ]
    gene_depths <- unname(log(Matrix::rowSums(expr_tmp)))
    data_list <- list(M = M,
                      N = nrow(expr_df),
                      G = length(unique(expr_df$gene)),
                      k = n.basis.fns,
                      spot_id = as.integer(expr_df$spot),
                      gene_id = as.integer(expr_df$gene),
                      phi = phi,
                      gene_depths = gene_depths, 
                      y = expr_df$gene_expression)
    stan_file <- system.file("approxGP2.stan", package = "bayesVG")
  } else {
    data_list <- list(M = M,
                      N = nrow(expr_df),
                      G = length(unique(expr_df$gene)),
                      k = n.basis.fns,
                      spot_id = as.integer(expr_df$spot),
                      gene_id = as.integer(expr_df$gene),
                      phi = phi,
                      y = expr_df$gene_expression)
    stan_file <- system.file("approxGP.stan", package = "bayesVG")
  }
  # compile model
  mod <- cmdstan_model(stan_file, compile = FALSE)
  mod$compile(cpp_options = cpp_options,
              stanc_options = list("O1"),
              force_recompile = TRUE,
              threads = n.cores)
  # fit model with desired algorithm
  if (verbose) {
    if (algorithm %in% c("meanfield", "fullrank")) {
      if (mle.init) {
        fit_mle <- mod$optimize(data_list,
                                seed = random.seed,
                                init = 0,
                                opencl_ids = opencl_IDs,
                                jacobian = FALSE,
                                iter = 1000L)
      } else {
        fit_mle <- NULL
      }
      fit_vi <- mod$variational(data_list,
                                seed = random.seed,
                                init = fit_mle,
                                algorithm = algorithm,
                                iter =  n.iter,
                                draws = n.draws,
                                opencl_ids = opencl_IDs,
                                elbo_samples = elbo.samples)
    } else {
      fit_vi <- mod$pathfinder(data_list,
                               seed = random.seed,
                               init = 0, 
                               num_threads = n.cores,
                               draws = n.draws,
                               opencl_ids = opencl_IDs,
                               num_elbo_draws = elbo.samples, 
                               max_lbfgs_iters = 100L, 
                               history_size = 25L)
    }
  } else {
    withr::with_output_sink(tempfile(), {
      if (algorithm %in% c("meanfield", "fullrank")) {
        if (mle.init) {
          fit_mle <- mod$optimize(data_list,
                                  seed = random.seed,
                                  init = 0,
                                  opencl_ids = opencl_IDs,
                                  jacobian = FALSE,
                                  iter = 1000L)
        } else {
          fit_mle <- NULL
        }
        fit_vi <- mod$variational(data_list,
                                  seed = random.seed,
                                  init = fit_mle,
                                  algorithm = algorithm,
                                  iter =  n.iter,
                                  draws = n.draws,
                                  opencl_ids = opencl_IDs,
                                  elbo_samples = elbo.samples)
      } else {
        fit_vi <- mod$pathfinder(data_list,
                                 seed = random.seed,
                                 init = 0, 
                                 num_threads = n.cores,
                                 draws = n.draws,
                                 opencl_ids = opencl_IDs,
                                 num_elbo_draws = elbo.samples, 
                                 max_lbfgs_iters = 100L, 
                                 history_size = 25L)
      }
    })
  }
  # optionally run diagnostics
  if (verbose) {
    fit_vi$cmdstan_diagnose()
  }
  # summarize posterior
  gene_mapping <- data.frame(gene = as.character(expr_df$gene),
                             gene_id = as.character(as.integer(expr_df$gene))) %>%
                  dplyr::distinct()
  amplitude_summary <- fit_vi$summary(variables = "amplitude") %>%
                       dplyr::rename_with(~paste0("amplitude_", .), .cols = -1) %>%
                       dplyr::rename(amplitude_ci_ll = amplitude_q5,
                                     amplitude_ci_ul = amplitude_q95) %>%
                       dplyr::mutate(gene_id = sub("^.*\\[(.*)\\].*$", "\\1", variable), .before = 1) %>%
                       dplyr::inner_join(gene_mapping, by = "gene_id") %>%
                       dplyr::relocate(gene) %>%
                       dplyr::select(-c(variable, gene_id)) %>%
                       dplyr::mutate(amplitude_dispersion = amplitude_sd^2 / amplitude_mean) %>%
                       dplyr::arrange(dplyr::desc(amplitude_mean)) %>%
                       dplyr::mutate(amplitude_mean_rank = row_number()) %>%
                       as.data.frame() %>%
                       magrittr::set_rownames(.$gene)
  if (verbose) {
    cli::cli_alert_success("Posterior summarization complete.")
  }
  # add gene-level estimates to object metadata
  if (inherits(sp.obj, "Seurat")) {
    version_check <- try({
      slot(sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]], name = "meta.data")
    }, silent = TRUE)
    if (inherits(version_check, "try-error")) {
      orig_metadata <- sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features
    } else {
      orig_metadata <- sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data
    }
    if (ncol(orig_metadata) > 0) {
      new_metadata <- dplyr::mutate(orig_metadata,
                                    gene = rownames(sp.obj),
                                    .before = 1) %>%
                      dplyr::left_join(amplitude_summary, by = "gene")
      if (inherits(version_check, "try-error")) {
        sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features <- new_metadata
      } else {
        sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data <- new_metadata
      }
    } else {
      non_tested_genes <- rownames(sp.obj)[!rownames(sp.obj) %in% unique(expr_df$gene)]
      null_df <- data.frame(gene = non_tested_genes,
                            amplitude_mean = NA_real_,
                            amplitude_median = NA_real_,
                            amplitude_sd = NA_real_,
                            amplitude_mad = NA_real_,
                            amplitude_ci_ll = NA_real_,
                            amplitude_ci_ul = NA_real_,
                            amplitude_dispersion = NA_real_,
                            amplitude_mean_rank = NA_integer_) %>%
                 magrittr::set_rownames(.$gene)
      amplitude_summary <- dplyr::bind_rows(amplitude_summary, null_df)
      amplitude_summary <- amplitude_summary[rownames(sp.obj), ]
      if (inherits(version_check, "try-error")) {
        sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.features <- amplitude_summary
      } else {
        sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@meta.data <- amplitude_summary
      }
    }
  } else {
    amplitude_summary_s4 <- SummarizedExperiment::rowData(sp.obj) %>%
                            as.data.frame() %>%
                            dplyr::mutate(gene = rownames(.), .before = 1) %>%
                            dplyr::left_join(amplitude_summary, by = "gene") %>%
                            S4Vectors::DataFrame()
    SummarizedExperiment::rowData(sp.obj) <- amplitude_summary_s4
  }
  # optionally save model fit to object's unstructured metadata
  if (save.model) {
    if (inherits(sp.obj, "Seurat")) {
      sp.obj@assays[[Seurat::DefaultAssay(sp.obj)]]@misc$model_fit <- fit_vi
    } else {
      sp.obj@metadata$model_fit <- fit_vi
    }
  }
  # finish time tracking 
  time_diff <- Sys.time() - time_start
  time_units <- ifelse(attributes(time_diff)$units == "secs", 
                       "seconds", 
                       ifelse(attributes(time_diff)$units == "mins", 
                              "minutes", 
                              "hours"))
  if (verbose) {
    time_message <- paste0("bayesVG modeling of ", 
                           length(naive.hvgs), 
                           " genes completed in ", 
                           as.numeric(round(time_diff, 3)), 
                           " ", 
                           time_units, 
                           ".")
    cli::cli_alert_success(time_message)
  }
  return(sp.obj)
}
